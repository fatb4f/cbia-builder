---
jupytext:
  formats: md
  text_representation:
    extension: .md
    format_name: markdown
    format_version: '1.3'
    jupytext_version: 1.16.0
kernel:
  name: python3
cbia:
  module: M2
  tp: TP2
  block_id: inf1250-m2-t2
  schema_version: 0.1.0
  generated: 2026-01-06
---
# Control Flow & Abstraction
> **Intent:** Identify control structures and place abstraction boundaries using functions.

Control flow describes the order in which instructions are executed. There are three fundamental control structures: sequence, selection, and iteration. Sequence executes steps in a fixed order. Selection chooses between alternatives based on a condition. Iteration repeats a block of steps while a condition holds. Together, these are sufficient to express any algorithm.

Abstraction is the practice of hiding internal details behind a boundary. Functions are the primary abstraction mechanism. A function defines a contract through its inputs and outputs while concealing how the result is produced. This allows a programmer to reason locally: if the contract is trusted, the internal steps do not need to be reconsidered.

Good abstraction aligns with problem decomposition. Each function should solve one sub-problem and avoid depending on hidden external state. Clear control boundaries reduce unintended interactions and make algorithms easier to test and modify. They also support reuse, since a well-defined function can be applied in multiple contexts.

Typical mistakes include functions that are too large, control flow that depends on implicit state, and duplicated logic that should have been abstracted. These issues increase complexity without increasing capability.

## Takeaway
Use clear control primitives and small abstractions.

## Key terms
sequence, selection, iteration, abstraction

---
_Source: INF1250 syllabus / feuille de route (TP2)_
